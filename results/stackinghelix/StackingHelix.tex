\documentclass[11pt]{article}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{gensymb}
\usepackage[affil-it]{authblk}
\usepackage[toc,page]{appendix}
\usepackage{pifont}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{relsize}
\usepackage{draftwatermark}
\usepackage[mathscr]{eucal}
\usepackage{amsmath, amssymb, graphics, setspace}
\usepackage{amsthm}
\usepackage[english]{babel}
 
\newcommand{\mathsym}[1]{{}}
\newcommand{\unicode}[1]{{}}

\newtheorem{exercise}{Exercise}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}

\SetWatermarkText{DRAFT}
\SetWatermarkScale{6}
\SetWatermarkLightness{0.95}

\DeclareMathOperator{\atantwo}{atan2}
\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\sense}{sense}

% \geometry{letter} % or letter or a5paper or ... etc
% \geometry{landscape} % rotated page geometry

% See the ``Article customise'' template for come common customisations

\title{Formulae for the Helix Formed by Stacking Similar Objects}
\author{Robert L. Read
  \thanks{read.robert@gmail.com}
}
\affil{Founder, Public Invention, an educational non-profit.}

\date{\today}

%%% BEGIN DOCUMENT
\begin{document}

\maketitle

%% \tableofcontents

\section{Introduction}

During the Public Invention Mathathon of 2018, software was created to view tetrahedra joined face-to-face in chains. It
was noted by the participants that when the rules for which face to add the next tetrahedron to were periodic, the resulting
chain was always a helix or a torus. A torus is a degenerate helix.

After some relfeciton, it became clear that any stack of objects of the same length joined at the same angles to each other repetitively form a helix. 
A specific example is a face-to-face connection of physical objects of the same length where the angles of the two joining
faces relative to each other control the angle and rotation of the axis at each joint. We have not yet found this simple idea articulated elsewhere. The purpose of this paper is to prove and to provide formulae for the resulting helix.

\section{A Warm-up: 2Dimensions}

Considering the problem in two dimensions may be a valuable introduction.
Suppose that we consider a polygon that that as two edges, called $A$ and $B$, and that we define the length $L$ of the
polygon as the distance between the midpoints of these edges. Suppose that we are only allowed to join these
polygons by aligning $A$ of one polygon to $B$ of another polygon, with their midpoints coincident. Let us
further assume that we disallow inversions of the polygon.  Let us imagine that we have a
countable number of polygons $P_i$ indexed from $0$. Then what shapes can we make by chaining these
polygons together?

Each joint $J_i$ between polygons $P_i$ and $P_{i+1}$ will place the axes of at the same angle, $\theta$, since
our polygons do not change shape. Let us define $\theta$ to be positive
if we move anti-clockwise from $P_i$ to $P_{i+1}$ and negative if we move clockwise. 
If $\theta = 0$, the joints will be collinear.

\begin{figure}
     \centering
     \includegraphics[width=0.80\textwidth]{figures/2DPolygonStacking.png}
     \caption{The rotatable prism of three objects}
  \label{fig:prismdiagram}
\end{figure}

If $\theta \neq 0$, it seems they polygon joints will always lie on a circle. A proof of this
is that each polygon has associated with it an isoceles triangle $A,B,C$, where $\angle CBA = \angle CAB = \theta/2$,
and $\angle ACB = (\pi - \theta)$. $AC$ and $BC$ are not necessarily aligned with an edge of the polygon.
The length $AB$ is $L$, and the lengths $AC$ and $BC$ are
$(L/2) / \sin{(\pi - \theta)/2}$. In any chain of polygons, these triangles all meet at point $C$, and there all
joints are on the circle centered at $C$ with radius $\frac{L}{2 \sin{\frac{\theta}{2}}}$.

An analogous, though far more complicated, result holds in three dimensions.

\label{sec:2d}
\section{The Discrete Helix}

In this section we consider discrete helix, or a helix evaluated only at regular points. Drawing lines between these
points create 3D polygon.

Following the Wikipedia artilce \url{https://en.wikipedia.org/wiki/Helix}, we set up a helix parametrically.
\begin{align*}
    P_x(t) &= r \sin{t}  \\
    P_y(t) &= r \cos{t} \\
   P_z(t) &= b t
\end{align*}
Such a helix has a radius of $r$ and slope (if $r \neq 0$) of $b/r$,. Note that a helix may be degenerate in two ways.
If $r = 0$, these equations become a line. If $b = 0$, these equations describe a circle in the $xy$-plane.
If $r = 0$ and $b = 0$, the figure is a point.

Such helixes are continuous, but we are investigating stacks of discrete objects. We in fact wish to derive
the parameters for a continuous helix from such discrete objects which constrain discrete points, so we wish
to study a helix evaluated at integral points. We call such an object a {\em discrete helix} or {\em delix (DEE-lix).}.
A discrete helix may be thought of as function that given an integer gives back a point in three space.
\begin{align*}
    P_x(n) &= r \sin{n \theta}  \\
    P_y(n) &= r \cos{n \theta} \\
   P_z(n) &= n d
\end{align*}

$d$ is the distance along the $z$-axis between adjacent points, and $\theta$ is the rotation around the $z$-axis between adjacent points. $r$ is the radius of the delix. If we think of the delix as describing a polyline in 3-space, we would like to investgiate
the properties of that polyline.

\begin{itemize}
\item $L$ is the distance between any two adjacent points.
\item $c$ is the length of a chord formed by the projection of the segment between two points into the $xy$-plane.
\item $\phi$ is the angle in the plane containing two points which is perpendicular to $xy$-plane
  (in other words the plane parallel to the $z$ axis containing two points.)
  \end{itemize}
These quantities are related:
\begin{align*}
    c = 2r\sin{\theta/2} \\
    L^2 &= c^2+d^2  \\
    \arctan{c/d}  &= \phi \\
\end{align*}

Now we are attempting to relate these properties to properties intrinsic to the joint or interface between
two segments or objects in the delix. If given an object, the length between the joint points $L$ is
easily measured. The most easily measured relationship between the segments
is the angle $\alpha$ in the plane containing both of the segments. (If the segments are coincident and therefore
parallel $\alpha$ will be $\pi$. If $\alpha < \pi/2$, the segment ``bends backward''.
The final measure that is needed is the rotation about a member between the elements attached to it.
Let us call this angle $\psi$.



\begin{align*}
    A &= P(-1)  \\
    B &= P(0) \\
    C &= P(1)
\end{align*}

$A,B,C$ form an isoceles triangle that contains $\overline{AB}$ and $\overline{BC}$, and therefore the angle $\alpha$ is in
this plane. Forming the kite $ABCO$, we see that one diagonal is $r$ and the other diagonal is $2 r \sin{\theta}$, where
$y = r \sin{\theta}$ is half of this diagonal. 

\begin{align*}
    y &= r \sin{\theta}  \\
    z^2 &= c^2 - y^2 \\
    z^2 &= c^2 - (r \sin{\theta})^2 \\    
    q^2 + z^2 &= L^2 \\
    q &= \sqrt{L^2 - z^2} \\
    q &= \sqrt{L^2 - (c^2- (r\sin{\theta})^2)} \\
    q &= \sqrt{L^2 + (r\sin{\theta})^2 - (2r\sin{\theta/2})^2 } \\        
    \sin{\alpha/2} &= q/L \\
    q &= L \sin{\alpha/2} \\
    \alpha/2 &= \arcsin{q/L} \\
    \alpha &= 2 \arcsin{\frac{\sqrt{L^2 + (r\sin{\theta})^2 -
          (2r\sin{\theta/2})^2}}
      {L}} \\ 
\end{align*}

Note $y$ is in the projected kite, $q$ is in the slanted kite.
Rearranging these relationships in terms of known quantites $L, \alpha, \psi$, we have:

\begin{align*}
  \sin{\alpha/2} &= q/L \\
  q &= L \sin{\alpha/2} \\    
  z^2 &= L^2 - q^2 \\
  %% Now we must use \psi
  \beta &= \frac{\pi - \theta}{2} \\
  \frac{z}{c} &= \cos{\beta} \\
  c &= \frac{z}{\cos{\beta}} \\
  y^2 &= c^2 - z^2 \\
  r &= \frac{y}{\sin{\theta}} \\
  d^2 &= L^2 - c^2 \\
  \phi &= \arctan{c/d} \\
\end{align*}

I think we can compute $\psi$ from $\theta$ easily enough. The problem is going the other way.

\subsection{An alternate approach}

Rather than starting with $\alpha$ and $\psi$ as inputs, we can think of a vector $v$ that
moves in the positive $\overline Z$ direction, $\overline Z = \overline P_1 - \overline P_0$, and
the angle $\theta$ which $Z$ rotates about the $z$-axis at each step. If a rotation matrix $M$
represents rotation about and $T$ represents translation along the $z$-axis, then $P_n = (M+T)^nP_n$.


\section{Three dimensions}




Consider a slender cylinder or prism with two faces $F_0,F_1$ cut at arbitrary angles to the axis of the cylinder.
Joining two such cylinders at the axes by placing $F_0$ angainst $F_1$ produced a joint with a difference in
angle between the axes of $\alpha$ and a rotation of the orienation of the faces about the axis of $\theta$.
Note that $\alpha$ and $\theta$ are a function of the vectors normal to the faces to be joined, but are not the same as them. $\alpha$ and $\theta$ are likely combinations of the face angles.

\begin{theorem}[Stacking Helix]
  The joints of a sequential stack of objects of length $L$ whose joints axis change by $\alpha$ and orientation rotate
  by $\theta$ are intersected by a helix of radius and pitch easily numerically computable
  from  $L,\alpha$, and $\theta$.
\end{theorem}

\begin{figure}
     \centering
     \includegraphics[width=0.95\textwidth]{figures/StackedSetup.png}
     \caption{The rotatable prism of three objects}
  \label{fig:prismdiagram}
\end{figure}

\begin{proof}

  In Figure \href{fig:prismdiagram}, let $L_i$ be the $i$th instance of the length-$L$ objects. Let $\alpha$ be the
  change in angle in the axes at a joint (the point were axes meet) measured in the plane containing the axes of both objects. (If these axes are parallel (and therefore coincident) define $\alpha$ to be 0.
  Let $\theta$ be the change in orientation relative to the axis,
  or, the half-angle formed by $L_0$ and $L_2$ when projected onto a plane normal to the axis of $L_1$.
  Without loss of generality, choose the measures of these angles in radians so that
  $0 \leq \theta < \pi/2$ and $0 \leq \alpha < \pi$.
  Take $\alpha < 0$ to mean that objects $L_0$ and $L_1$ bend away from each other,
  and $\alpha > 0$ to mean that the objects $L_0$ and $L_1$ bend toward each other.

  If $\theta = 0$ and $\alpha > 0$, the stack will form a circle-like structure or radius 
  $\frac{L}{2 \sin{\frac{\alpha}{2}}}$, as shown in Section \ref{sec:2d}, where as if
  $\theta = 0$ and $\alpha < 0$, then stack will form a sawtooth-like structure.

  Note that any angle $\alpha$ is possible, if we do not concern oursleves with the self-collision
  of physical objects. $\alpha > \pi/2$ means the stack ``turns back on itself'' to some extent.

  If we arrange object $L_1$ so that its axis lies on the $x$-axis and its midpoint is at the origin,
  $L_0$ and $L_1$ extend from it symmetrically in the projection onto the $yz$-plane along the $x$-axis, which is always possible, and define $h$ to be the height of the faces of $L_0$ and $L_2$ along the $y$-axis
  and $w$ to be the distances between these faces in the $z$-dimesnion. Then we have:

  \begin{align*}
z &= L \sin{\alpha} \\
w &= z \sin{\theta} \\
h &= \sqrt{z^2 - w^2} \\
  \end{align*}

  Now we seek the formula for the helix which intersects the joints. To find the radius of this helix,
  we conceptually place our three objects in a cylinder, with the axis of $L_1$ along the surface
  of the cylinder aligned with the axis. We can size this cylinder to include the joints at the
  extreme ends of $L_2$ and $L_0$ as well. However, the $L_1$ axis lies on the surface, but
  the axes of $L_0$ and $L_2$ in general do not. If there exists a helix which intersects all
  joints, all axes will cut through this cylinder in the same way, creating chords in the projection
  into the $yz$-plane of the same length. Name these chords $c_0,c_1, and c_2$.

  Because we will need them later, we work out the geometry of this prism-like stack of three
  objects completely.
  \begin{itemize}
  \item The three objects are named $L_0,L_1,$ and $L_2$.
    $L_0$ has joints $P_0$ and $P_1$,
    $L_1$ has joints $P_1$ and $P_2$,
    $L_2$ has joints $P_2$ and $P_3$.
  \item  $x$ is the total length of the prism along the $x$-axis.
  \item $z$ is the length of the ``face'' of the prism, and the length
    of the chord before any rotation $\phi$ about the $y$-axis.
  \item $w$ is half of the width of the prism in the $z$-dimension.
  \item $h$ is the height of the prism in the $y$-dimension.
  \item $D$ is the length of the diagonal from $P_0$ to $P_3$.
  \item $\psi$ is the angle of $\overline{P_0P_3}, \arctan{(w/(x/2))}$.
    \item $\phi$ is the amount we will have to rotate the prism about the $y$-axis.
    \end{itemize}
Given these defintions about our assumptions, the cord lengths are:
\begin{align*}
  \psi &= \arctan{(w/(x/2))} \\
D &= \sqrt{4w^2+x^2} \\
c_1 &= L \sin{\phi} \\
c_2 &= \sqrt{h^2 + ((1/2)(D\sin{(\psi+\phi)}-L\sin{\phi})^2}  \\
c_0 &= c_2 \\
  \end{align*}
  

  We can imagine turing our 3-object stack and simulataneously increasing the size of our intersecting
  cyliner. If we turn the stack about the $y$-axis by $\phi$ degrees and keep the cylinder intersection
  the two faces of $L_1$, then the length of the $L_1$ chord will gradually increase. At the same time,
  the $L_0$ and $L_2$ chords will change their length, possibly increasing or decrasing.
  When $\phi = 0$, $c_0 = z, c_1 = 0, c_2 = z$.

  Equating these quantities to find when $c_2 = c_1$, we have a trigonometric equation with
  a single unknown, $\phi$.
    \begin{align*}
      L \sin{\phi} &= \sqrt{h^2 + ((1/2)(D\sin{(\psi+\phi)}-L\sin{\phi})^2} \\
      %% To put this in the language of Wolfram Alpha....
      %% L* sin(x) = sqrt(A + ((1/2) *(D* sin(x + B) - L * sin(x)))^2)
      %% At present, Mathemtatic does not appear able to solve this.
    \end{align*}

    Although Mathematica does not appear to be able to solve this equation, it appears
    to be a smooth equation in the variable $\phi$ and we believe from the physical
    structure of the problem that will have only a single solution, so we can
    solve this numerically with a Newton-Raphson solver easily.
    
    Thus, by rotating our stack of objects $\phi$ degrees around the $y$-axis 
    all four faces of our three objects intersect a cylinder on its surface with
    equal rotational and axial distance. The axial distance between any two joints
    on the same object is $L \cos{\phi}$,
    and the length of the projected chord is $L \sin{\phi}$.

    The points $P_0,P_1,P_2,$ and $P_3$ now exist on a cylinder or unknown radius parallel
    to $x$-axis, and are evenly spaced along and evenly rotated about the axis of the
    cylinder. The joints points thus coincide with a general helix.

    Let us choose our coordinate system so that the $x$-axis corresponds to the
    axis of the helix. The general equation for the helix is:

\begin{align*}
    P_x(n) &= \kappa  t  \\
    P_y(n) &= r \cos{t} \\
   P_z(n) &= r \sin{t}
\end{align*}

We seek to discover $r$ and $\kappa$ based on our knowledge of $P_3$ and $P_2$.
In particular, we can deduce from the axial spacing there exists some $t_0$ such
that $P_2 = P(t_0)$ and $P_3 = P(3t_0)$.
Since we know that after rotation that:

  \begin{align*}
    P_{3z} &= (D/2) \sin{\phi + \psi} \\
    P_{3z} &= r\sin{3t_0} \\
    P_{2z} &= \sin{\phi} \\
    P_{2z} &= r\sin{t_0}
  \end{align*}
  We can use symbolic computation to solve this system of 2 equations and 2 unkowns:
  \begin{align*}
    r\sin{3t_0} &= (D/2) \sin{\phi + \psi} \\
    r\sin{t} &= \sin{\phi}
  \end{align*}
  Defining symbols:
  \begin{align*}
    E &= (D/2) \sin{\phi + \psi} \\
    F &= \sin{\phi}
  \end{align*}
  Wolfram alpha solves the system:
  \begin{align*}  
    r\sin{3t_0} &= E \\
    r\sin{t_0} &= F
  \end{align*}
  giving the result ($3F \neq E$ and $F \neq 0$), and ignoring multiples of $2\pi$ in $t$:

  
  \begin{align*}  
    r &= \frac{2F^{\frac{3}{2}}}{\sqrt{3F - E}} \\
    t_0 &= -2 \arctan{x}
      \frac{r +
        \sqrt{- \frac{F^2(F+E)}{E-3F}
        }
      }
           {F}
     \\
  \end{align*}
  From which, using $P_{2x} = L/2 = \kappa t_0$, we conclude:
  \begin{align*}  
    r &= \frac{2F^{\frac{3}{2}}}{\sqrt{3F - E}} \\
    \kappa &= \frac{L}{4 \arctan{\frac{r + \sqrt{- \frac{F^2(F+E)}{E-3F}}}{F}}}
  \end{align*}.
  Putting this all together we have:
  \begin{align*}
    a &= L \cos{\alpha} \\
    x &= L + 2a \\
    z &= L \sin{\alpha} \\
    w &= z \sin{\theta} \\
    h &= \sqrt{z^2 - w^2} \\
    D &= \sqrt{4w^2+x^2} \\
    \phi &= \arctan{\frac{z}{L}} \\
    E &= (D/2) \sin{\phi + \psi} \\
    F &= \sin{\phi} \\
    r &= \frac{2F^{\frac{3}{2}}}{\sqrt{3F - E}} \\
    \kappa &= \frac{L}{4 \arctan{\frac{r + \sqrt{- \frac{F^2(F+E)}{E-3F}}}{F}}}
  \end{align*}
  Using these values derived exclusively from the inputs $L,\alpha, and \theta$, we can
  evalute the formula for the general helix only and integral values of $n$ to
  obtian a formula for precise the joint points of this any such stack.
\begin{align*}
    P_x(n) &= \kappa  t0 (1 + 2n)  \\
    P_y(n) &= r \cos{t0 (1 + 2n)} \\
    P_z(n) &= r \sin{t0 (1 + 2n)}
\end{align*}

\end{proof}

\section{Checking against comprehensible values}

Unfortunately, the complexity of these formualae exceed the author's comprehension.
However, we may check these formuale by graphing them against comprehensible
examples. Obvious examples are extreme solutions, where $\alpha$  and $\theta$ are
$0$ or $\pi/2$, for example. We also have the particular non-trivial example
of the Boerdick-Coxeter tetrahelix, formed by regular tetrahedra, which has
been studied enough to have a known pitch.



\section{Implications}

One of the implcations of having a formulaic understanding of the math
is that it may be possible to design helixes
of any radius and pitch by designing periodic (possibly scalene) segments. Combined with slight
irregularites, this means that you have a basis of design molecular helices
out of ``atoms'' which correspond to our objects.

This would mean that if you wanted to build a brace of length exactly 3 meters
with bars of exactly 1/2 meter you would be able to come as close to this
as mathematically possible.






\section{Applied to Periodic Regular Simplex Chains}

\begin{corollary}
  Every regular simplex chain formed by a periodic generator has a helical structure.
  \end{corollary}

Prove or disprove that {\em every} periodic 3D Generator generates a figure contained within a cylinder of unbounded length but bounded diameter.

Note: Every example that we have tested exhibits this property. We believe it is a property of any repeated structure, not related to simplices.
However, we do not yet know the name of this theorem or principle. We conjecture that every stack of repeated truncated prisms
forms a helical aperigon, which is hinted at but not stated in the Wikipedia article\url{https://en.wikipedia.org/wiki/Skew_apeirogon}.

Note: Rob believes a proof that any periodic structure fits within a cylinder is possible, and that it should be possible to give a formulaic bound
on the diameter of this cylinder (under some assumptions.) The key to the proof is to use symmetry and focus on the the center of three
such objects, observing that the other two must necessarily bend towards or away from each other in a way describable by two angles.
A formula for the cylinder as a function of these angles would convincingly complete the proof.

Note: This paper may be critical.

\url{https://arxiv.org/pdf/1610.00280.pdf}

\url{https://www.impan.pl/wydawnictwa/preprints_impan/p741.pdf}

\url{https://math.stackexchange.com/questions/878051/why-does-a-3d-line-of-segments-with-constant-angles-always-make-a-helix/878079#878079}

\bibliographystyle{unsrt}
\bibliography{gluss}


\end{document}

The following math in Mathematica may be useful.

Note: Mathematica has build in Vector Angle function that can be used for alpha!!

c = 2 r Sin[theta/2]

Chord[r_,theta_] := 2 r Sin[theta/2]
1 == c^2 + d^2
DZ[r_,theta_] := Sqrt[1 - Chord[r,theta]]
(* Note, this may be a problem --- Chord lenght can be diameter (2r), but I am treating it as 1 here *)
(* Some radiuses are not possible for some thetas with a length of one *)
(* Maximum radius as a function of theta *)
Mxr[theta_] := MaxValue[1 == 2 r Sin[theta/2],{r}]
Mxr[theta_] := 1/ (2  Sin[theta/2])


 Note: I should go ahead and make these functions....

(* P0 = {0, r, 0} *)
(* P1 = {r Sin[theta], r Cos[theta], d} *)
(* P2 = {r Sin[2 theta], r Cos[2 theta], 2 d} *)
(* P3 = { r Sin[3 theta], r Cos[3 theta], 3 d} *)
(* S0 = P0 - P1 *)
(* S1 = P1 - P2 *)
(* S2 = P2 - P3 *)
P[n_,r_,theta_] := { r Sin[n theta], r Cos[n theta], n DZ[r,theta]}
S[n_,r_,theta_] := P[n,r,theta] - P[n+1,r,theta]

Alpha[r_,theta_] := VectorAngle[S[0,r,theta],S[1,r,theta]]

alpha = ArcCos[S0.S1]
Solve[alpha == ArcCos[S0.S1], alpha]

f[r_, theta_] := 
 ArcCos[-1 + (r - r Cos[theta]) (-r Cos[theta] + r Cos[2 theta]) + 
   4 r^2 Sin[theta/2]^2 - 
   r Sin[theta] (-r Sin[theta] + r Sin[2 theta])]

Plot3D[f[r, theta]/ Degree, {r, 0, 2}, {theta, -Pi/6, Pi/6}, 
 AxesLabel -> Automatic]


Plot3D[Alpha[r, theta]/ Degree, {r,0,N[Mxr[Pi]]}, {theta, 0, Pi}, 
 AxesLabel -> Automatic]


Note: Given that we can compute $\alpha$ from $r,\theta$ in this way, one interesting thing to ask
is simply what is the minimum or maximum r (or theta) that matches an alpha. The maximum r is the
largest helix that matches, the minimum is the smallest. But with $\psi$ we will know more.

PlaneNormal[a_, b_] := Normalize[Cross[a, b]]

Psi[p0_, p1_, v_] := 
With[{n = PlaneNormal[p0, p1]}, ArcSin[(n.v) /(Norm[v] Norm[n])]]

PsiC[rx_,thetax_] := 
With[{r = rx,theta = thetax}, Evaluate[Psi[S[0,r,theta],S[1,r,theta],S[2,r,theta]]]]

Plot3D[PsiC[r, theta]/ Degree, {r, 0, N[Mxr[Pi/2]]}, {theta, 0, Pi/2}, 
 AxesLabel -> Automatic]


Note: A strategy for computation is: given alpha, find maximum or minimum radius.
Then slow change radius until \psi if find.  However, Mathematic has optimization
built in, so we may be able to use an energy function.

Enrg[alpha_,psi_,r_,theta_] := (Alpha[r,theta] - alpha)^2 + (PsiC[r,theta] - psi)^2

FindMinimum[Enrg[Pi/10,Pi/10,r,t],{r,t}]

(* These seem to work, but they produce rules, instead of values, what up with that? *)

Rx[alpha_,psi_] := r /. FindMinimum[Enrg[alpha,psi,r,t],{r,t}][[2]][[1]]
Tx[alpha_,psi_] := t /.  FindMinimum[Enrg[alpha,psi,r,t],{r,t}][[2]][[2]]

Plot3D[Rx[a,p]/Degree, {a,0,Pi/10},{p,0,Pi/10}]

(* Now that we can in theory find Rx, Tx as a function of alpha and psi,
It is important that we have a check function (or two.)
The best check would be to use a reconstruction based on transformations
of alpha and psi. I need to think about how this should be done with a
RollPitchYaw Matrix, and in what order. First you by \alpha, then you rotate by \psi.
I think we are doing ``Pitch, Roll, Yaw''. First we Pitch by \alpha, then
we Roll into the plane of the joint, then we yaw by \psi.
In fact what we are trying to do is to fly a little airplane in a helical course.
``Pitch down by alpha'', ``Yaw by psi'', ``roll so that we are perpendicular
to the the plane of the last joint''.  Maybe we never need to the roll component.
I want intrinsic angle rotation (by the definition.) We do seem to have a mobile
frame of reference.
So in fact I want EulerMatrices, not RollPitchYaw matrices.

Euluer[{\alpha,\beta,\gamma},{a,b,c}], where a,b,c = 1,2,3, let us specify those.
So we need to define how our mobile frame works. We will want $y$ to always point
``out'' of the helix, ``z'' to point along the motion'', and $x$ to be
tangential to the helix.

If we start with the intrinsic frame aligned with the extrinsic frame, repeated
transofrmations will produce a helix, but not about the $z$ axis.
We have so far described our mostion as ``rotate about y'' by $\alpha$, then
rotation about $x by $\psi$. Then our $z$ axis would be pointed in the
write direction, we would translate  by $z$, in the intrinsic frame of refrence,
and repeat.

Note, mathematica seems to have a way to render a helix, this would be very useful to me:
ListPointPlot3D[
Table[Table[{t, Cos[t + s Pi/2], Sin[t + s Pi/2]}, {t, 0, 
      5 Pi, .2}], {s, 4}], BoxRatios -> Automatic]

Graphics3D[
GeometricTransformation[{Hue[#/Pi], Sphere[{5, 0, 0}, 1]}, 
  EulerMatrix[{#, Pi/2, #}]] & /@ Range[0, 2 Pi, Pi/16]]

My claim is that we can somehow combine an EulerTransformation with a translation
to end up with a helix.

We can call GeometricTransoforamtion on an Euler matrix, can we pass a vector
as an object? Can we create an object of length L which is a vector
and then create a transformation?

Graphics3D[Arrow[{{1, 1, 1}, {1, -1, 2}}], Axes -> True, 
  AxesLabel -> {"X", "Y", "Z"}, ImageSize -> Large]

Graphics3D[
GeometricTransformation[{Hue[#/Pi],Arrow[{{1, 1, 1}, {1, -1, 2}}] }, 
Composition @@ {
     TranslationTransform[{1, 1, 1}],
      EulerMatrix[{0, Pi/2, #}]
}] & /@ Range[0, 2 Pi, Pi/16]]


 EulerMatrix[{Pi/15, Pi/20, 0}] [1,1,1]


 myt = TranslationTransform[{0, 0, 1}] EulerMatrix[{Pi/15, Pi/20, 0}]


 Graphics3D[{
  Opacity[1]
  , Red
  , Arrow[{{0, 0, 0}, {1, 0, 0}}]
  , Green
  , Arrow[{{0, 0, 0}, {0, 1, 0}}]
  , Blue
  , Arrow[{{0, 0, 0}, {0, 0, 1}}]
  , Opacity[0.2]
  , GeometricTransformation[Cuboid[-{1, 1, 1}/4, {1, 1, 1}/4],
   Composition @@ {
     RotationTransform[Pi/4, {0, 0, 1}]
     , TranslationTransform[{1, 1, 1}]
     }
   ]
 }]
 
 Graphics3D[{
  Opacity[1]
  , Red
  , Arrow[{{0, 0, 0}, {1, 0, 0}}]
  , Green
  , Arrow[{{0, 0, 0}, {0, 1, 0}}]
  , Blue
  , Arrow[{{0, 0, 0}, {0, 0, 1}}]
  , Opacity[0.2]
  , GeometricTransformation[Cuboid[-{1, 1, 1}/4, {1, 1, 1}/4],
    Composition @@ {
       RotationTransform[Pi/15,{0,1,2}],
     , TranslationTransform[{1, 1, 1}]
     }
   ]  & /@ Range[0, 5, 1]
 }]


 Graphics3D[
   GeometricTransformation[{Hue[#/Pi],Arrow[{{1, 1, 1}, {1, -1, 2}}] },
       Composition @@ {
       RotationTransform[Pi/15,{0,1,2}],
     , TranslationTransform[{1, 1, 1}]
     }
 ]]


 Composition @@ {
     RotationTransform[Pi/4, {0, 0, 1}]
     , TranslationTransform[{1, 1, 1}]
 }

 Graphics3D[
   
  (GeometricTransformation[Cuboid[-{1, 1, 1}/4, {1, 1, 1}/4], 
   Composition @@ {RotationTransform[Pi/4, {0, 0, #}], 
     TranslationTransform[{1, 1, #}]}]) & Range[3]

 ]

double[x_] := 2 x
 
Nest[double,#,4] & Range[3]

(* Now, what we really want to do here, is  construct
a transform out of \alpha, \pi, ending up with the arrows head to tail

Clear[ComposeN]
ComposeN[0] = ScalingTransform[{1,1,1}]
ComposeN[1] = Composition @@ {
  RotationTransform[ Pi/6, {0, 1, 0}],
  Composition @@ {
    TranslationTransform[{1, 1, 1}],
    RotationTransform[ Pi/6, {0, 0, 1}]
  }
}

ComposeN[n_] :=  Composition[ComposeN[Floor[n/2]],ComposeN[Ceiling[n/2]]]


 myarrows = 
 Table[
   GeometricTransformation[{
     Arrow[{{0, 0, 0}, {0, 0, 2}}],
     Arrow[{{0, 0, 0}, {0,1/2, 0}}]},   
     ComposeN[i]
   ],{i,1,10}
   ] 
 
 Graphics3D[myarrows]


 (* I think to do what I want, I need to do my own transformationns. *)
 (* An object is a vector and an upvector.
 The 0th object is a z-aligned vector starting at the origin, with a y upvector.
 The n+1th object is:
 A) Take the nth object (AB), find the head B of the vector.
 B) Create a vector of length N pointing in the same direction as the nth object.
 C) Translate it along the nth object to the head.
 D) Relative to 
 E) Rotate it in the AB coordinate frame in the Y direction by Alpha.
 F) Rotate it in the X direction by Psi.
 G) Apply these same arguments to the up Vector.

 Note that Mathematica has powerful RotationMatrix functions built in to which
 we can use the Nth vectors as input, to rotate in a plane. So in this sense
 we may actually be able to accomplish this.
*)


